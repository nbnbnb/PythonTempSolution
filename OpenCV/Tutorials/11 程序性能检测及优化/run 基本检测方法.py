'''
在图像处理中你每秒钟都要做大量的运算，所以你的程序不仅要能给出正
确的结果，同时还必须要快。所以这节我们将要学习：
• 检测程序的效率
• 一些能够提高程序效率的技巧
• 你要学到的函数有： cv2.getTickCount,cv2.getTickFrequency
等
除了 OpenCV， Python 也提供了一个叫 time 的的模块，你可以用它来测量
程序的运行时间。另外一个叫做 profile 的模块会帮你得到一份关于你的程序
的详细报告，其中包含了代码中每个函数运行需要的时间，以及每个函数被调
用的次数。如果你正在使用 IPython 的话，所有这些特点都被以一种用户友好
的方式整合在一起了。我们会学习几个重要的，要想学到更加详细的知识就打
开更多资源中的链接吧。

'''

import cv2
import numpy as np

'''
cv2.getTickCount 函数返回从参考点到这个函数被执行的时钟数。所
以当你在一个函数执行前后都调用它的话，你就会得到这个函数的执行时间
（时钟数）。
cv2.getTickFrequency 返回时钟频率，或者说每秒钟的时钟数。所以
你可以按照下面的方式得到一个函数运行了多少秒

有些技术和编程方法可以让我们最大的发挥 Python 和 Numpy 的威力。
我们这里仅仅提一下相关的，你可以通过超链接查找更多详细信息。我们要说
的最重要的一点是：首先用简单的方式实现你的算法（结果正确最重要），当结
果正确后，再使用上面的提到的方法找到程序的瓶颈来优化它。

1. 尽量避免使用循环，尤其双层三层循环，它们天生就是非常慢的。
2. 算法中尽量使用向量操作，因为 Numpy 和 OpenCV 都对向量操作进行
了优化。
3. 利用高速缓存一致性。
4. 没有必要的话就不要复制数组。使用视图来代替复制。数组复制是非常浪
费资源的。

就算进行了上述优化，如果你的程序还是很慢，或者说大的训话不可避免的话，
你你应该尝试使用其他的包，比如说 Cython，来加速你的程序。

'''

img=cv2.imread(r'D:/Python/OpenCV Tutorial/images/mountaion.png')

e1=cv2.getTickCount()

for i in xrange(5,49,2):
	img=cv2.medianBlur(img,i)  # 中值滤波
	
e2=cv2.getTickCount()

time=(e2-e1)/cv2.getTickFrequency()

print(time)


